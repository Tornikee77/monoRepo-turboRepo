Monorepo-ს დეტალური მიმოხილვა
მონორეპო არ არის მხოლოდ "ბევრი საქაღალდე ერთად". ეს არის სისტემა, სადაც კოდის რეუზაბელურობა (ხელახლა გამოყენება) აყვანილია მაქსიმუმამდე.

პრაქტიკული მაგალითი: ვალიდაციის ლოგიკა
წარმოიდგინე, გაქვს ფორმა, სადაც მომხმარებელი წერს იმეილს. შენ გჭირდება ამ იმეილის შემოწმება (Validation) როგორც Frontend-ზე (მომხმარებლისთვის), ისე Backend-ზე (უსაფრთხოებისთვის).

Multi-repo-ს დროს: ორჯერ წერ ერთსა და იმავე ფუნქციას სხვადასხვა რეპოზიტორიაში. თუ წესი შეიცვალა, ორივეგან უნდა შეცვალო.

Monorepo-ს დროს:
შექმნი პაკეტს packages/validation და გამოიყენებ ორივეგან:

```js
// packages/validation/index.ts
export const isValidEmail = (email: string) => {
  return /^\S+@\S+\.\S+$/.test(email);
};

// apps/web/register-page.tsx (Frontend)
import { isValidEmail } from "@my-project/validation";

// apps/api/auth-controller.ts (Backend)
import { isValidEmail } from "@my-project/validation";

```

Monorepo-ს უპირატესობები:
Dependency Management: ყველა პროექტი იყენებს React-ის ერთსა და იმავე ვერსიას. აღარ გაქვს სიტუაცია, როცა ერთი აპლიკაცია v17-ზეა და მეორე v18-ზე.

Shared Types: თუ TypeScript-ს იყენებ, Backend-ის მონაცემთა ტიპები (Interfaces) პირდაპირ ხელმისაწვდომია Frontend-ისთვის.

1. ატომური ცვლილებები (Atomic Commits)
   წარმოიდგინე, გაქვს API და Mobile App. API-ში შეცვალე ველის სახელი user_id-დან userId-ზე.

Multi-repo-ში: უნდა დაააფდეითო API, დაელოდო მის გაშვებას (Deployment), მერე შეხვიდე Mobile App-ის რეპოში, იქაც შეცვალო და იმედი იქონიო, რომ ვერსიები ერთმანეთს დაემთხვევა.

Monorepo-ში: ერთ Git Commit-ში აკეთებ ორივე ცვლილებას. კოდის ბაზა ყოველთვის სინქრონიზებულია. არ არსებობს მომენტი, როცა ერთი ნაწილი "გასწრებია" მეორეს.

2. კოდის ხელმისაწვდომობა და აღმოჩენადობა
   დიდ კომპანიებში (Google, Meta, Uber სწორედ მონორეპოს იყენებენ) დეველოპერებს ხშირად უწევთ სხვისი დაწერილი კოდის ნახვა. როცა ყველაფერი ერთ რეპოშია:

Code Search: მთელ ორგანიზაციაში ერთი ძებნით პოულობ ნებისმიერ ფუნქციას.

Collaboration: თუ Frontend დეველოპერს აინტერესებს, როგორ მუშაობს Backend-ის ენდპოინტი, ის უბრალოდ გადადის მეზობელ საქაღალდეში, ნაცვლად სხვა რეპოზიტორიის ძებნისა.

3. სტანდარტიზაცია
   მონორეპო გაიძულებს გქონდეს ერთიანი წესები. მაგალითად, ყველა პროექტი იყენებს ერთსა და იმავე ESLint კონფიგურაციას ან TypeScript ვერსიას. ეს ამცირებს "Decision Fatigue"-ს (გადაწყვეტილების მიღების დაღლილობას).

Multi-repo-ს დროს: ორჯერ წერ ერთსა და იმავე ფუნქციას სხვადასხვა რეპოზიტორიაში. თუ წესი შეიცვალა, ორივეგან უნდა შეცვალო.
